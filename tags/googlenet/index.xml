<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>GoogLenet - Tag - Good Young</title>
        <link>https://goodyoung.github.io/tags/googlenet/</link>
        <description>GoogLenet - Tag - Good Young</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 30 Jul 2024 22:58:52 &#43;0900</lastBuildDate><atom:link href="https://goodyoung.github.io/tags/googlenet/" rel="self" type="application/rss+xml" /><item>
    <title>[CS231n] 09.CNN Architectures</title>
    <link>https://goodyoung.github.io/posts/cs231n/lecture9/</link>
    <pubDate>Tue, 30 Jul 2024 22:58:52 &#43;0900</pubDate>
    <author>GoodYoung</author>
    <guid>https://goodyoung.github.io/posts/cs231n/lecture9/</guid>
    <description><![CDATA[개요 CS231n의 9강에 대한 내용을 정리 할 것이다.
9강에 나오는 CNN Architecture중에 GoogLeNet과 ResNet에 대해서 살펴볼 예정이다.
GoogLeNet 이때부터 이제 Network를 깊게 효율적을 만들기 시작했다.
Network를 깊고 효율적으로 만들기 위해서 GoogLeNet에서는 Inception module을 추가하였다. Inception Module
로컬 네트워크의 한 유형이다. 네트워크의 네트워크 병렬로 서로 다른 크기의 filter를 병렬로 돌리는 것이다. no FC layers
Stride와 padding을 통하여 입력과 출력 차원을 일치시키고 depth를 높였다. 문제는 computational complexity이다. Pooling layer가 depth를 유지하기 때문에 every layer에서 전체적인 depth가 깊어진다. 이를 해결하려고 &lsquo;boottleneck layer&rsquo;가 나온다. 1*1 filter를 사용하여 depth를 줄인다. 따라서 기존과 확연히 다른 연산을 수행하는 것을 확인할 수 있게 된다. 1*1 를 사용하면 정보 손실이 발생할 수 있지만 이러한 예측을 수행하는 경우 이들의 조합을 계산하여 추가적으로 비선형성을 도입하므로 ?? 또한 auxiliary classification output이 있다. - To inject additional gradient at lower layers - 중간 layer도 도움이 된다. 깊은 네트워크 때문에 gradient vanishing 현상을 극복하려고 inject를 한다. 따라서 이런 추가 신호를 제공한다.
ResNet 2015 우승자 revolution of Depth인 만큼 많이 깊은 network이다
엄청 깊게 cnn을 쌓으면 더 나은 결과가 나오나. 아니다.
- Train시 overfitting이 예상이 되어 오류가 아주 적을 것이라 예상을 했지만 그 조차도 아니다. - overfitting이 아니다. - optimization problem문제이다. - 적어도 깊은 layer는 shallower의 성능은 기본적으로 있어야 하지만 그 조차도 아니다. - 깊은 layer는 shallower model보다 최적화 하기 어렵다. - 이걸 해결하려고 residual connection이 나왔다. - H(x) 바로 하는 것이 아니라 x를 뺀 나머지(잔차)를 학습을 한다 - FC 층이 없다 오직 output linear층만 있다. Resnet50으로 가면 bottleneck layer을 사용하여 11 conv를 사용한다. - 11으로 depth를 처음에 줄이고 나중에 depth를 높인다.]]></description>
</item>
</channel>
</rss>
