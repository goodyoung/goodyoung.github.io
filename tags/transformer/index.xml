<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Transformer - Tag - Good Young</title>
        <link>https://goodyoung.github.io/tags/transformer/</link>
        <description>Transformer - Tag - Good Young</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 24 Jul 2024 11:32:59 &#43;0900</lastBuildDate><atom:link href="https://goodyoung.github.io/tags/transformer/" rel="self" type="application/rss+xml" /><item>
    <title>[Paper Review]Attention Is All You Need</title>
    <link>https://goodyoung.github.io/posts/paper/transformer/</link>
    <pubDate>Wed, 24 Jul 2024 11:32:59 &#43;0900</pubDate>
    <author>GoodYoung</author>
    <guid>https://goodyoung.github.io/posts/paper/transformer/</guid>
    <description><![CDATA[개요 요즘 모든 분야에서 자주 사용되고 있는 아키텍쳐인 Transformer에 대한 논문 리뷰를 해보려고 한다. Abstract 기존의 sequence transduction model(sequence 간 변형이 이루어 지는)은 complex recurrent나 cnn기반으로 구성되어 있다. 그리고 좋은 성능을 내는 것이 attention 기반에 encoder &amp; decoder 기반으로 연결되어 있는 네트워크이다. 본 논문에서는 오로지 attention mechanism만 사용하는 Transformer를 제안한다. 즉, 순환이나 cnn의 연산을 사용하지 않는 네트워크이다. 이는 훈련시간 절감, 행렬곱을 이용하여 병렬적으로 수행하면서 번역 작업에 우수한 품질을 보여준다. English-German 번역 작업에 28.4 BLEU를 달성하였고 다른 task에서도 잘 작동한다. Introduction RNN, long-term memory, GRU이 language modeling, machine translation 문제에서 SOTA를 달성하고 있다. 많은 연구가 encoder-decoder의와 순환 language model의 성과를 달성하려고 하고 있다. 순환 모델의 연산 특성은 training sample 내에서 병렬화를 방해하며, 시퀀스 길이가 길어질수록 메모리 제약으로 인해 예제 간 배칭이 제한되므로 병렬화가 중요해집니다. 기존 RNN의 단점 따라서 기존의 RNN의 단점에 대해서 간략히 살펴 보겠다. 위 그림처럼 sequence에 포함되어 있는 순서 정보를 정렬하고 이것을 차례대로 hidden state의 값을 반복을 통하여 갱신하기 때문에 병렬적으로 수행하기에 어렵다는 사실을 알 수 있게 된다. 또한 input 단어가 많아지면 encoder의 마지막 부분의 출력인 context vector를 만들어야 하기 때문에 병목의 문제도 있다. 다시 논문 내용으로 넘어가면 Factorization trick과 conditional computation의 연구로 인해 이러한 문제점은 상당히 해결되고 있지만 여전히 sequential computation은 제약이다. Attention은 input과 output의 거리에 관여하지 않고 model의 종속성을 허락해준다. 이러한 attention mechanism은 주로 순환 신경망과 함께 사용이 되어 왔다. Attention RNN처럼 하나의 context vector가 소스 문장의 모든 정보를 가지고 있어야하는 단점을 해결하기 위해 나온 기법이 Attention이다. Attention은 매번 출력 단어를 만들어 낼 때마다 소스 문장의 출력 정보 중에서 어떤 정보가 가장 중요한지 가중치를 부여해서 출력 단어를 보다 효과적으로 생성할 수 있게 한다. 간단히 매번 소스 문장에서의 출력 전부를 decoder의 입력으로 받는 방식이다. 결론적으로 본 논문에서 제안하는 Transformer는 순환을 피하고 대신에 attention mechanism에 온전히 의존하여 input과 output 사이의 ``global dependencies를 이끈다. 이러한 구조는 병렬 처리에 특화되었다. Background 기존 연구들은 CNN을 사용하여 sequenrtial computation을 줄이는데 초점을 맞추었지만 이 방법은 다른 position 사이의 종속성을 배우기 쉽지 않다. 하지만 Multi-Head Attention의 방법을 사용하여 상수 시간으로 줄였다. 또한 기존 순환 end-to-end memory network는 attention mechanism을 사용했다. 하지만 Transformer에서는 RNN이나 CNN을 사용하지 않고 input output의 representation을 계산하는 전체의 self-attention을 사용한다. 여기서 나온 Self-Attention이란 input으로 들어오는 각각의 단어가 서로에게 얼만큼의 영향을 미치는지 알려준다. 문맥에 대한 정보를 잘 학습하도록 만드는 것이다. Model Architecture 기존 모델들은 encoder-decoder구조를 따르는데 이전 단계에서 생성한 symbol을 활용해서 decoder가 다음번에 나올 output을 만든다. Transformer 또한 encoder-decoder의 구조를 띄는데 모델을 순환적으로 사용하지 않고 attention mechanism만 활용하여 sequence에 대한 정보를 한 번에 입력으로 준다는 것이 특징이다. 위의 그림은 transformer의 전체적인 구조인데 이를 앞으로 하나씩 살펴볼 예정이다. Encoder and Decoder Stacks Encoder부분은 여러번 stack이 가능한 구조이고 하나의 layer는 크게 두가지의 구조를 지닌다. multi-head self attention feed-forward network 또한 이 두가지의 구조 모두 residual connection을 활용하여 Identity mapping을 거치게 한다. Decoder부분은 여러번 stack이 가능한 구조이고 보통 encoder랑 같은 layer의 개수랑 맞춘다. Decoder third sub-layer에 encoder의 output값을 활용하여 multi-head attention을 수행하도록 한다. residual connection을 활용하여 보다 더 쉽게 global optima를 찾도록 한다. 이전에 등장한 단어들만 참고할 수 있도록 mask를 씌워서 multi-head attention을 사용할 수 있도록 한다. Attention Attention Function은 쿼리와 key-value 쌍을 output으로 mapping을 한다. Query, keys, values, output들은 다 vector이다. Query(Q): 물어보는 주체 (어떤 단어가 가장 중요했는지를 key에서 계산하여 결과를 낸다.]]></description>
</item>
</channel>
</rss>
