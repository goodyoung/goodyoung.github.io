<!DOCTYPE html>
<html lang="en-us">
    <head>
	<meta name="generator" content="Hugo 0.121.2">
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <title>Good Young</title><meta name="Description" content="This is my cool site"><meta property="og:title" content="Good Young" />
<meta property="og:description" content="This is my cool site" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://goodyoung.github.io/" /><meta property="og:site_name" content="My cool site" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Good Young"/>
<meta name="twitter:description" content="This is my cool site"/>
<meta name="application-name" content="My cool site">
<meta name="apple-mobile-web-app-title" content="My cool site"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://goodyoung.github.io/" /><link rel="alternate" href="/index.xml" type="application/rss+xml" title="Good Young">
    <link rel="feed" href="/index.xml" type="application/rss+xml" title="Good Young"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css"></noscript><link rel="preload" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
        <noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "WebSite",
        "url": "https:\/\/goodyoung.github.io\/","inLanguage": "en-us","author": {
                "@type": "Person",
                "name": "GoodYoung"
            },"description": "This is my cool site","name": "Good Young"
    }
    </script></head>
    <body data-header-desktop="auto" data-header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Good Young">GoodYoung Dev Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Good Young">GoodYoung Dev Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw" aria-hidden="true"></i>
            </a></div>
    </div>
</header><main class="main">
                <div class="container"><div class="page home" data-home="posts"><div class="home-profile"><div class="home-avatar"><a href="/posts/" title="Posts"><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="/images/profile.jpeg"
        data-srcset="/images/profile.jpeg, /images/profile.jpeg 1.5x, /images/profile.jpeg 2x"
        data-sizes="auto"
        alt="/images/profile.jpeg"
        title="/images/profile.jpeg" /></a></div><div class="home-subtitle"><div id="id-1" class="typeit"></div></div><div class="links"><a href="https://github.com/goodyoung" title="GitHub" target="_blank" rel="noopener noreffer me"><i class="fab fa-github fa-fw" aria-hidden="true"></i></a><a href="mailto:goodyoung.goh@gmail.com" title="Email" rel="me"><i class="far fa-envelope fa-fw" aria-hidden="true"></i></a><a href="/index.xml" title="RSS" target="_blank" rel="noopener noreffer me"><i class="fas fa-rss fa-fw" aria-hidden="true"></i></a></div></div>
<article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/cs231n/lecture2/">[CS231n] 02.Image Classification</a>
    </h1><div class="post-meta"><span class="post-author"><a href="https://goodyoung.github.io" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>GoodYoung</a></span>&nbsp;<span class="post-publish">published on <time datetime="2024-05-14">2024-05-14</time></span>&nbsp;<span class="post-category">included in <a href="/categories/dl/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>DL</a>&nbsp;<a href="/categories/theory/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Theory</a>&nbsp;<a href="/categories/lecture/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Lecture</a></span></div><div class="content">개요 CS231n을 공부하면서 정리를 위해 글을 작성해보려고 한다. 1강의 내용은 컴퓨터 비전에 대해 전반적인 역사, 이 course를 통해 얻게 될 내용들에 대해서 소개를 해주었다. 따라서 따로 정리할 것은 없어서 정리하지는 않았다. The Problem 컴퓨터는 사람과 달리 이미지를 숫자로 인식을 한다. 따라서 사람이 의미하는 것과 컴퓨터가 이해하는 것에는 차이(Semantic Gap)가 있기 마련이다. 또한 컴퓨터가 image를 인식할 때 여러 문제(problem)들이 발생하게 된다. Viewpoint variation (카메라의 움직임) Illumination (색상 차이) Deformation (다양한 모습) Occlusion (부분적으로 물체 보이는 현상) Background Clutter (배경 혼란 현상) Intraclass variation (다양한 종류) 따라서 우리는 이런 problem들을 극복할 수 있는 robust하고 확장성이 뛰어난 모델을 만들어야 한다. 이런 모델들을 만들기 위해서 Data-Driven Approach(하나의 접근 방식)를 제안한다. Data-Driven Approach에 대해서 아래에 설명을 작성했다.
image와 label들의 dataset을 모은다. 간단한 분류기를 machine learning에 의해 훈련킨다. (함수에서 train) 새로운 이미지를 가지고 분류기를 평가한다. (함수에서 predict) Nearest Neighbor 이 방법은 학습 데이터와 새로운 이미지들을 비교해서 학습 데이터 중에서 가장 유사한 이미지로 레이블을 예측하는 방법이다. Nearest Neighbor에서 이때 유사한 이미지로 판단하기 위해서 L1(manhattan) distance가 있다. L1 distance는 새로운 이미지의 pixel에 학습 데이터를 뺀 절대값들의 합을 구하여 그 합들이 가장 최소로 나온 이미지를 유사하다고 판단하는 방법이다. [그림 1] Nearest Neighbor 위 그림과 함께 Nearest Neighbor의 과정을 보자면 train 과정에서 모든 훈련 데이터를 저장한다. 그리고 predict 과정에서 모든 훈련 데이터를 비교하여 가장 유사한 훈련 데이터 image를 찾게 된다. 이 과정에서 train: O(1), predict: O(N)(# of iunput)의 시간 복잡도를 가지게 되는데 이것은 잘못되었다고 표현을 한다. 왜냐하면 우리는 보통 분류기가 빠르게 예측하기(predict)를 원하지만 Nearest Neighbor에서는 그것이 반대가 되어있는 것을 알 수 있게 된다. 또한 Nearest Neighbor알고리즘은 가장 가까운 이웃만을 보기 때문에 위와 같은 초록색이 대부분인 영역에서 노란색을 예측하는 문제가 발생 할 수 있다. 따라서 K-Nearest Neighbor알고리즘이 나오게 된다. K-Nearest Neighbor [그림 2] K-Nearest Neighbor 그 다음으로 가까운 Neighbor을 K개의 만큼 찾고, 그것끼리 다수결의 결정으로 예측을 하는 K-Nearest Neighbor방법이 있다. 또 이때 유사도를 결정할 때 L1 distance가 아닌 L2(Euclidean) distance의 계산식이 있다. 이것은 L1과 달리 좌표계가 무엇이든 상관이 없지만 L1의 경우에는 좌표계에 따라 계산값이 변할 수 있다. 각각 어떤것이 좋은지는 데이터의 성격에 따라 다르다 input 데이터가 각각의 항목이 중요한 성격(salary, 성별, 연봉 등)을 가진다면 L1이 적당할 수 있지만 어떤 역할인지 상관이 없으면 L2가 더 좋을 수 있다. 위 그림 2를 보게 되면 K가 커질 수록 좀 더 경계들이 부드러워지는 모습을 볼 수 있게 된다. 그렇다면 K가 무조건 커지면 좋은 것이냐? 그건 또 아니다. 이때 중요한 것이 적절한 K를 결정하는 것이 중요하다. 이런 K같은 요소들을 Hyperparameter이라고 부르고 다음으로 이런 적절한 Hyperparameter을 선택하는 방법에 대해서 설명하겠다. Hyperparameter 이런 Hyperparameter는 직접 시도해보고 가장 좋은 값을 찾는 것이 정답이다. [그림 3] Hyperparameter Setting idea #1: 학습데이터만을 학습하여 하이퍼 파라미터를 선택
idea #2: train한 모델을 바탕으로 Test set에서만 잘 동작하는 하이퍼 파라미터를 선택
idea #3: train set으로 모델을 학습, validation set으로 가장 좋았던 하이퍼 파라미터 선택, validation set에서 고른 하이퍼 파라미터를 바탕으로 test set을 test시작
따라서 이런 적절한 Hyperparameter가 무엇인지 결정할 때 위 3개의 방법 중 idea #3방법이 제일 좋다. 왜냐하면 idea1,2는 unseen data에 대한 정확도가 떨어진다. 결국 idea #2도 새로운 data에 약한 특성을 보인다. 예를 들어, idea #2일 때 K값을 바꿔가면서 이 중 가장 높은 성능을 지닌 K를 정한다고 했을 때 이는 test데이터에 좋은 성능을 보이는 K값인 것이다.</div><div class="post-footer">
        <a href="/posts/cs231n/lecture2/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/image-classification/">Image classification</a>,&nbsp;<a href="/tags/cs231n/">CS231n</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/paper/fcn/">[Paper Review]Fully Convolutional Networks for Semantic Segmentation(FCN) & Implement</a>
    </h1><div class="post-meta"><span class="post-author"><a href="https://goodyoung.github.io" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>GoodYoung</a></span>&nbsp;<span class="post-publish">published on <time datetime="2024-04-14">2024-04-14</time></span>&nbsp;<span class="post-category">included in <a href="/categories/paper-review/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Paper Review</a>&nbsp;<a href="/categories/dl/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>DL</a>&nbsp;<a href="/categories/implement/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Implement</a></span></div><div class="content">개요 Semantic Segmentation 문제를 해결하기 위해 제안된 딥러닝 모델인 Fully Convolutional Networks(이하 FCN) 논문 리뷰를 해보려고 한다. Abstract FCN은 convolutional network 자체로 end-to-end 학습, pixels-to-pixels을 훈련을 하고 semantic segmentation에서 state-of-the-art(이하 SOTA)를 달성했다.
이때 나오는 end-to-end 학습이란 독립적인 것이 아니라 하나의 모델에서 작업이 다 끝나고, 모델의 모든 filter들이 학습이 가능한 학습을 하는 학습 방법이라고 생각하면 된다. [그림 1] end-to-end 학습 end-to-end 학습이 아닌 모델인 pattern recognition모델은 사람들이 직접 filter를 설계하여 classifier만 학습을 하는 방법이다. 본 논문의 핵심 아이디어는 임의의 크기인 input과 input과 같은 크기의 output을 생성하는 fully convolutional network를 구축하는 것이다. 또한 기존의 classification networks(AlexNet, VGG net, GoogLeNet)을 통해 transfer learning을 통한 fine-tuning을 진행하였다. 마지막으로 모델의 deep layer에서 얻은 의미(Semantic) 정보와 shallow layer에서 얻은 외관(Appearance)정보를 섞는 skip architecture를 정의하였다. [그림 2] CNN layers Semantic information deep, coarse(굵다) layer
CNN에서 제일 deep한 위치에 있는 layer들이 객체의 외관은 파악하기 힘든 반면에 feature들이 활성화가 된 부분을 보면 의미가 있는 정보를 나타낸다. Appearance information shallow, fine layer
CNN의 첫 번째 layer에 있는 filter들은 보통 edge feature들을 추출하기 때문에 윤곽과 관련된 feature들을 추출한다. Introduction Convolutional networks의 등장으로 인해 classification, local task(object detection, key-point등)와 같은 분야에서 엄청난 발전을 이룰 수 있었다. 이러한 Convolutional networks의 다음 단계는 segmentation을 위한 모든 pixel에 대한 예측이다. 또한 기존의 방법들 (patchwise training, pre-post processing)등의 수고로움을 해결할 수 있다고 나와있다. 이때 설명하는 patchwise training이란 FCN이 나오기 전 segmentation 학습 방법론 이다. [그림 3] Patchwise training Patchwise learning 방식 특정 크기의 patch를 설정 및 CNN input 이때의 input -&gt; CNN에 의해 classification이 된다. 이때 특정 class로 분류가 되었다면, 해당 patch 중앙에 위치한 pixel을 분류된 class로 분류한다. 이 과정을 슬라이딩 윈도우 방식으로 모든 픽셀을 반복한다. 따라서 Patchwise learning의 방법에는 여러 단점이 생기게 된다. 많은 계산량 patch끼리 겹칠 때의 중복 계산의 우려, patch의 크기를 크게할 때 분류가 애매한 상황 patch 크기를 줄여주면 low resolution(해상도가 낮음)의 문제 마지막으로 FCN이 등장하기 전 semantic한 정보와 location한 정보를 어떻게 잘 조합할 지 몰랐다. 이를 해결하기 위해서 skip architecture가 나오게 된다. Fully convolutional networks 이제까진 기존 CNN에 대한 설명과 FCN이 나오기전의 모델들의 단점들을 살펴보며 FCN 모델의 우수성을 추상적으로 설명했다. 이젠 FCN의 알고리즘을 구체적으로 설명 해보려고 한다. Adapting classifiers for dense prediction [그림 4] FC -&gt; Convolutional layers 전형적인 분류 net(LeNet, AlexNet &hellip;)은 FC층 때문에 고정적인 input size와 non-spatial output을 가진다. 입력 이미지의 크기에 비례하여 FC층에 들어가기 위해 flatten되는 neuron의 수가 비례하기 때문에 input size가 고정적이다. 이때 flatten 되기 때문에 이미지의 공간적 정보의 손실이 있게 된다. 따라서 이러한 linear한 FC층을 [그림 1]처럼 Fully Convolutional한 구조로 변경을 하였다. 이로써 모든 layer에 Conv를 적용하여 ground truth를 각 layer의 출력으로부터 얻을 수 있어 forward와 backward가 계산 효율성에서 장점을 얻는다. 또한 단점이었던 공간 정보의 손실이 없어지는 것도 해결하였다. convolutionalization된 층의 resulting map에 해당되는 특정 위치가 특정 patch 상의 CNN 결과랑 같게 된다. 지금까진 FCN구조의 encoder 부분을 설명한 것과 같다. 다음으론 output map(coarse output)으로 부터 dense prediction을 하는 방법을 알아 볼 것 이다. Shift-and-stitch is filter rarefaction dense prediction을 하기 위해 output map을 upscaling을 해야 한다. upscaling을 하기 위한 방법으로 본문에선 shift-and-stitch방법을 고려했다고 나타난다. [그림 5] shift and stitch 그림을 토대로 max pooling을 하고 위치 정보를 저장하여 원래의 이미지 크기로 upscaling이 가능하다. 하지만 계산 비용이 큰 단점이 있게 된다.</div><div class="post-footer">
        <a href="/posts/paper/fcn/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/fcn/">FCN</a>,&nbsp;<a href="/tags/implement/">Implement</a>,&nbsp;<a href="/tags/%EB%85%BC%EB%AC%B8-%EB%A6%AC%EB%B7%B0/">논문 리뷰</a>,&nbsp;<a href="/tags/computer-vision/">computer vision</a>,&nbsp;<a href="/tags/segmentation/">segmentation</a>,&nbsp;<a href="/tags/%EB%85%BC%EB%AC%B8-%EA%B5%AC%ED%98%84/">논문 구현</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/segmentation/segmentation-3/">[DL]Image Segmentation 3</a>
    </h1><div class="post-meta"><span class="post-author"><a href="https://goodyoung.github.io" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>GoodYoung</a></span>&nbsp;<span class="post-publish">published on <time datetime="2024-04-04">2024-04-04</time></span>&nbsp;<span class="post-category">included in <a href="/categories/dl/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>DL</a>&nbsp;<a href="/categories/theory/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Theory</a></span></div><div class="content">개요 이전 글에 이어서 Image segmentation의 접근 방법 (Edge 기반 방법, 영역 기반 방법)에 대해서 알아보고자 한다. 먼저 Edge 기반 방법의 Edge Detection에 대해 알아보겠다. Edge Detection Edge Detection은 영상(Image)의 Edge(경계선, 윤곽선)을 검출하는 것이다. 이때 Edge는 깊이, 색깔, 조명이 달라서등 다양한 원인에 의해서 생길 수 있다. Edge는 이러한 원인들에 의해서 밝기가 급격하게 변한다라고 말할 수 있다. 따라서 영상상의 Edge의 밝기를 분석했을 때 Edge에 해당하는 부분은 픽셀의 밝기가 급격하게 변한다라는 특징을 가지고 있다. [그림 1] intensity function 위 [그림 1]을 보면 중간 그림 처럼 아래로 떨어지는 부분이나, 위로 오르는 부분이 Edge이다. 이 부분을 미분을 해보면 우측 그림 처럼 극값이 Edge라고 할 수 있다. 따라서 Edge 검출 방법은 미분을 이용하여 근처 픽셀과의 변화율을 찾아 검출하는 것이다. 변화율을 찾을 때 1차 미분, 2차 미분을 이용하는 방법이 있다. Edge Detection에선 1차 미분의 중앙 차분 방법을 사용하는데 이 방법을 영상 속 픽셀에 적용시키기 위하여 미분 마스크를 사용하게 된다. 미분 마스크는 가로(x), 세로(y) 방향이 있고 x,y 방향 둘 다 계산(1차 미분)을 하여 두 개의 결과를 합쳐서 일정 threshold를 기준으로 Edge를 검출 할 수 있게 된다. [그림 2] Edge Detection flow [그림 3] Mask Filter 미분 마스크의 여러 형태(마스크의 값)이 있는데 이 중 일반적으로 간단한 sobel을 많이 사용한다. 라이브러리 cv2의 Sobel 메서드를 사용하면 미분 마스크를 사용해볼 수 있다. import cv2 img = cv2.imread(&#34;some_img.png&#34;, cv2.IMREAD_GRAYSCALE) dx = cv2.Sobel(img,-1,1,0, delta = 128) # delta는 시각화를 위하여 dy = cv2.Sobel(img,-1,0,1, delta = 128) # delta는 시각화를 위하여 3*3 필터로 각각 x방향, y방향 편미분을 하는 방식 Region Growing 영역 기반 방식에서 가장 많이 사용되는 방식이 region-growing 알고리즘이다. 이 방식은 **기준 픽셀(SEED)**을 정하고 기준 픽셀과 비슷한 속성을 갖는 픽셀로 영역을 확장하여 더 이상 속성을 갖는 것들이 없으면 확장을 마치는 방식이다. **기준 픽셀(SEED)**를 정하는 방식은 Thresholding &amp; Morphological등의 방법이 사용될 수 있다. Thresholding을 사용하여 그림을 추출 한 후 구체적인 포인트를 뽑기 위해 Morphological Erosion을 하는 방식이 있다. 시드포인트를 정한 후 확장하는 방법도 다양하다. 원래의 시드 픽셀과 비교 기존 시드 픽셀과 비교하여 일정 범위 이내가 되면 영역을 확장하는 방법. (잡음에 민감, seed에 민감) 확장된 위치의 픽셀과 비교 원래 시드 픽셀의 위치가 아니라 영역이 커지는 만큼 시드 픽셀도 방향에 맞게 같이 커지는 방식. [그림 4] Region Growing Reference https://faceyourfear.tistory.com/78 https://gaussian37.github.io/vision-concept-edge_detection/ https://jstar0525.tistory.com/53#0.-edge https://blog.naver.com/laonple/220875555860 https://blog.naver.com/laonple/220890216653 https://medium.com/dawn-cau/region-based-segmentation-c1b2e06a3e2f </div><div class="post-footer">
        <a href="/posts/segmentation/segmentation-3/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/computer-vision/">computer vision</a>,&nbsp;<a href="/tags/basic/">basic</a>,&nbsp;<a href="/tags/image-preprocessing/">image preprocessing</a>,&nbsp;<a href="/tags/dl/">DL</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/segmentation/segmentation-2/">[DL]Image Segmentation 2</a>
    </h1><div class="post-meta"><span class="post-author"><a href="https://goodyoung.github.io" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>GoodYoung</a></span>&nbsp;<span class="post-publish">published on <time datetime="2024-04-02">2024-04-02</time></span>&nbsp;<span class="post-category">included in <a href="/categories/dl/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>DL</a>&nbsp;<a href="/categories/theory/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Theory</a></span></div><div class="content">개요 이전 segmentation 관련 글에 대해 조사를 해보니 segmentation을 위한 다양한(전통적인) 이미지 방법론(전처리)이 많은 사실을 알게 되었다. 따라서 이에 대해 정리를 해보려고 한다. Image segmentation은 접근 방법에 따라 3가지로 나뉜다. 픽셀 기반 방법 thresholding에 기반한 방식으로 threshold에 따라 픽셀 별로 이진화를 할 때 많이 사용한다. 전역, 지역으로 적용하는 영역에 따른 구분도 가능하고, 적응적, 고정 방식으로 경계값을 설정하는 방식으로도 구분 가능하다. Thresholding 방식 등이 있다. Edge 기반 방법 Edge를 추출하는 필터 등을 사용하여 영상으로부터 경계를 추출하는 방법이다. Edge Detection 방법 등이 있다. 영역 기반 방법 위 두 방식은 데이터 noise에 민감하다. 영역 기반 방법은 동질성에 기반하여 다른 데이터 보다 의미있는 영역으로 나누는데 적합하지만 동질성을 규정하는 rule을 어떻게 정할 것인가는 문제이다. region growing, region merging 방법 등이 있다. 따라서 Image segmentation의 기본적인 방법론 픽셀 기반 방법에 대해 설명하고자 한다. Thresholding 영상 처리에서 Thresholding은 영상(Image)을 분할하는 가장 간단한 방법이다. Thresholding은 말 그대로 특정 임계값을 정하고 그보다 작으면 0, 크면 1로 이진화를 하는 간단한 방법이다. T(Threshold)가 한개만 적용한 경우
T(Threshold)가 두개 적용한 경우
그럼 T의 값은 어떻게 결정할까? 다음으로 T의 값을 설정하는 3가지 방법에 대해서 알아볼 것이다. Global Thresholding 첫번째 방법으로는 Global Thresholding 방법이 있다. 이 방법은 영상 픽셀값의 누적 분포를 알 수 있는 히스토그램을 사용한다.
히스토그램의 peak(정점)의 분포를 확인하여 적절한 임계값을 찾아내는 방식이다. 아래는 임계값을 찾는 예시이다. [그림 1] Gray Scale Image [그림 1]을 보면 Gray Image가 있는 것을 확인 할 수 있다. 우리는 이 Image의 픽셀을 히스토그램으로 시각화 하여 peak를 찾을 것이다. [그림 2] Gray Scale Image Histogram [그림 2]를 보게 되면 [그림 1]의 픽셀을 빈도수 별로 나누어 히스토그램을 그린 것 이다. Peak가 크게 2개 있는 것을 확인이 가능하고 우리는 그 사이 값으로 임계값을 설정하면 된다. [그림 3] Final Image [그림 3]은 임계값을 225으로 잡고 Thresholding을 적용시킨 Image이다. 영상속 모양을 가진 물체들을 잘 탐지한 것을 볼 수 있게 된다.
관련 코드는 GITHUB에 있다. Otsu Thresholding 두번째 방법으로는 Otsu Thresholding 방법이 있다. 이 방법은 peak의 경계가 명확하지 않고, peak 근처에 데이터가 몰려있지 않은 경우, 즉 히스토그램만 분석해서 잘 안나오는 영상에 대해서 최적의 T를 결정하는 방법이다. Otsu Thresholding방법은 오츠의 이진화 알고리즘을 이용하여 자동으로 T의 값을 찾는 방법으로 알려져있다. 영상에서 임의의 T값을 기준으로 하여 T보다 작은 픽셀 (T보다 어두운 픽셀)과 T와 같거나 큰 픽셀을 각각 다른 2개의 그룹으로 나누어 각각의 평균과 표준편차를 구한다. Otsu Thresholding은 2개 그룹 사이의 그룹 내 분산을 최소화 하거나 혹은 그룹 간 분산을 최대로 하는 방향으로 T를 정하면, 가장 적절한 임계값을 자동으로 얻을 수 있게 된다. 왜냐하면 그룹 내로는 비슷한 분포를(분산 최소) 보이고, 그룹 간으로 다른 성격을 띄는(분산이 최대) 분포를 보이면 그 T값이 우리가 위에서(Thresholding) 정한 histogram에서 peak을 보고 T를 정한 것이랑 같기 때문이다. 위 그림을 Otsu Thresholding을 사용하여 처리하는 과정을 나타낸 예시이다.
[그림 4] Otsu Thresholding Histogram 16. 원본 그림의 픽셀 분포를 나타낸 것이며, Otsu Thresholding을 통해 가장 적절한 T의 값을 찾은 것이다. [그림 4]에 있는 그래프를 봤을 때 Thresholding방식으로 바로 적절한 T의 값을 찾기란 번거로웠을 것이다. [그림 5] Otsu Thresholding Output [그림 5]는 T값을 기준으로 이진 변환을 한 결과이다. 관련 코드는 GITHUB에 있다.
Thresholding이나 Otsu Thresholding방식은 전역 임계값을 사용한 것이다. 전역 임계값은 단순성과 효율성에서 이점이 있지만 조명이나 특정 noise, pixel 분포가 복잡한 영상에 상당한 변화가 있는 영상에는 적합하지 않을 수도 있다.</div><div class="post-footer">
        <a href="/posts/segmentation/segmentation-2/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/computer-vision/">computer vision</a>,&nbsp;<a href="/tags/basic/">basic</a>,&nbsp;<a href="/tags/image-preprocessing/">image preprocessing</a>,&nbsp;<a href="/tags/dl/">DL</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/segmentation/segmentation-1/">[DL]Image Segmentation 1</a>
    </h1><div class="post-meta"><span class="post-author"><a href="https://goodyoung.github.io" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>GoodYoung</a></span>&nbsp;<span class="post-publish">published on <time datetime="2024-03-20">2024-03-20</time></span>&nbsp;<span class="post-category">included in <a href="/categories/dl/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>DL</a>&nbsp;<a href="/categories/theory/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>Theory</a></span></div><div class="content">개요 컴퓨터 비전(Computer Vision)의 분야에 있어서 대표적인 기술은 객체 분류(Object Classification), 객체 탐지 및 위치 식별(Object Detection &amp; Localization), 객체 분할 (Object Segmentation), 이미지 캡셔닝(Image captioning)등이 있다. 이런 다양한 기술 중 하나인 이미지 분할(Image Segmentation)에 대해서 설명하고자 한다. 이미지 분할(Image Segmentation) [그림 1] Image Segmentation의 예 이미지 분할(Image Segmentation)은 신경망을 훈련시켜 이미지를 픽셀 단위로 분할하는 것이다. 위의 그림과 같이 이미지를 분할하게 되면 각각의 픽셀을 라벨(범주)별로 분류하는 작업을 거치게 된다. 이미지 분할(Image Segmentation)은 이미지 탐지(Image Detection)과는 다른 문제이다. 위의 그림 처럼 사람(Person)이라는 라벨을 가진 이미지에서도 여러 사람들을 분류 하는 것이 이미지 탐지(Image Detection)이다. 이미지 분할(Image Segmentation)은 여러 사람들을 사람이라는 하나의 객체(라벨) 안에 각각 다른 하나의 객체로 구분한다. 다음으론 이런 이미지 분할(Image Segmentation)도 Semantic Segmentation, Instance Segmentation, Panoptic Segmentation등 다양한 종류가 존재하는데 이에 대해 설명하고자 한다. 의미적 분할(Semantic Segmentation) [그림 2] Sementic Segmentation의 예 의미적 분할은 Semantic: '의미론'의 단어 뜻 처럼 이미지 내에 있는 객체들을 의미있는 단위로 분할하는 것을 말한다. 이미지를 봤을 때 큰 의미로 분할을 하게 된다. (위의 예시로 보자면 큰 객체들 위주: 사람, 자전거, 배경) 하지만 의미적 분할은 큰 의미로만 분할을 하지 하나의 객체 안에서 개별 객체로 구분하지는 않는다.(이미지에서 다른 사람이더라도 상관없이 같은 라벨로 표현) 따라서 이를 보완하기 위해 나타난 것이 인스턴스 분할(Instance Segmentation) 이다. 인스턴스 분할(Instance Segmentation) [그림 3] Instance Segmentation의 예 인스턴스 분할은 객체별로 각각 다른 라벨을 가지게 한다. 또한 각 객체의 경계 또한 식별이 가능하게 된다. 인스턴스 분할은 의미적 분할처럼 각 픽셀별로 어떤 카테고리에 속하는지 계산하는 것이 아닌 각 픽셀별로 object가 있는지 없는지 여부만 계산한다.
2-stage detector(Mask R-CNN)에서 객체들을 bounding box를 통해 localization을 시킨다. 그 후 localize된 RoI마다 class의 개수 만큼 binary mask(instance인지 아닌지) 마스크를 씌워준다. RoI별로 class 개수만큼 output 채널이 존재하고 동일 class더라도 서로다른 객체(instance)로 판별. (-&gt; 객체 별 각각 다른 객체) 즉, RoI가 focus하는 객체(instance)부분만 value를 갖도록 한다. 용어 설명 2-stage detector: localization과 classification이 순차적으로 이루어지는 방식 Localization: 객체 주변의 bounding box를 식별하여 객체의 위치를 찾는 방식 RoI: 관심 영역, 이미지 상에서 관심 있는 영역
따라서 인스턴스 분할은 background와 같이 구분하기 애매한 것들은 제외시키고 object를 대상으로 한다. 파놉틱 분할(Panoptic Segmentation) [그림 4] Panoptic Segmentation의 예 파놉틱 분할은 위 두가지 방법인 의미적, 인스턴스 분할을 합친 개념이다. 즉, 모든 pixel에 대해 라벨을 분류하고 객체 별 각각 다른 객체로 판별하는 과정을 수행하는 것이다. Image Segmentation 활용 분야 의학 사진(Medical Image)에서 많이 활용되고 있다. 예를 들어 환자의 체내 이미지에서 다양한 질병을 감지하는데 사용되고 있다. [그림 5] Image Segmentation의 활용 예-1 자율 주행 자동차처럼 자기 스스로 이미지를 분석하여 움직이는 것들은 이미지 분할의 도움을 받을 수 있게 된다. [그림 5] Image Segmentation의 활용 예-2 Reference https://velog.io/@dongho5041/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98Image-Segmentation https://velog.io/@lighthouse97/%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98Image-Segmentation https://velog.io/@claude_ssim/%EC%8B%9C%EA%B0%81%EC%A7%80%EB%8A%A5-Instance-segmentation https://ganghee-lee.tistory.com/44 https://ganghee-lee.tistory.com/34 </div><div class="post-footer">
        <a href="/posts/segmentation/segmentation-1/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/computer-vision/">computer vision</a>,&nbsp;<a href="/tags/segmentation/">segmentation</a>,&nbsp;<a href="/tags/%EB%94%A5%EB%9F%AC%EB%8B%9D/">딥러닝</a></div></div>
</article><article class="single summary" itemscope itemtype="http://schema.org/Article"><h1 class="single-title" itemprop="name headline">
        <a href="/posts/blog-construct/hugo_blog_2/">Hugo 블로그 구축기 -2 With Mac</a>
    </h1><div class="post-meta"><span class="post-author"><a href="https://goodyoung.github.io" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw" aria-hidden="true"></i>GoodYoung</a></span>&nbsp;<span class="post-publish">published on <time datetime="2024-03-05">2024-03-05</time></span>&nbsp;<span class="post-category">included in <a href="/categories/tech/"><i class="far fa-folder fa-fw" aria-hidden="true"></i>tech</a></span></div><div class="content">개요 Hugo 블로그 구축기 -1에서 블로그 기본적인 토대를 만들었다면 해당 글에선 본격적으로 블로그를 내 입맛에 맞게 꾸미려고 한다. 그 방법으로 hugo.toml 변경, shell을 이용한 git update 자동화 방법을 소개하려고 한다. Step 1: 구성 파일 변경 hugo에서는 블로그 구성 파일을 hugo.toml로 관리를 하게 된다. 여기서 블로그 구성 파일이란 블로그 웹의 기본 설정(메뉴 설정, 테마, 포스트 및 페이지 등)을 구성할 수 있게 하는 파일이다. 이제 hugo.toml을 Vim 편집기를 사용하여 수정하려고 한다.
$ cd my_blog # 생성 폴더로 이동 $ vi hugo.toml # vim 편집기로 구성 파일 편집 자신이 정한 테마의 Github에 config.toml or hugo.toml에 가이드라인을 보고 참고하여 추가하면 된다. 테마의 Github에 내용이 없거나, 좀 어려운 경우는 자신의 테마의 Github이 아니라 자신이 정한 테마를 사용한 블로그를 운영하는 사람의 github.io 레포지토리를 들어가서 파일을 참고하는 방법도 추천한다. Step 2: 배포 파일 설정 Hugo 블로그 구축기 -1 Step 3에서 배포 파일을 담을 레포지토리 하나만 관리하게 구성하였다고 하였다. 레포지토리가 하나라고 해도 블로그의 변경사항을 Github Pages에 적용하려면 은근히 직접 치기 귀찮다. 따라서 수정 사항을 한 번에 Github에 올릴 수 있는 배포 파일을 만들 것 이다. # 기존 배포 시 실행 코드 $ hugo $ cd public $ git add . $ git commit -m &#34;Update: {commit message}&#34; $ git push origin master $ cd .. 리눅스 쉘 스크립트를 활용하여 배포 파일을 만들면 된다. $ cd my_blog # 생성 폴더로 이동 $ touch deploy.sh # 배포 쉘 스크립트 파일 생성 $ chmod 777 deploy.sh # 파일 실행 권한 부여 배포 파일을 만들었으면 스크립트를 작성하면 된다. $ #!/bin/bash $ echo -e &#34;\033[0;32mDeploying updates to GitHub...\033[0m&#34; # Build the project. $ hugo -t loveit # hugo -t &lt;여러분의 테마&gt; # Go To Public folder, sub module commit $ cd public # Add changes to git. $ git add . # Commit changes. $ msg=&#34;rebuilding site `date +%y-%m-%d`&#34; $ if [ $# -eq 1 ] # 호출 시 인자를 하나 받았는지 아닌지 $ then msg=&#34;$1&#34; $ fi $ git commit -m &#34;$msg&#34; # Push source and build repos. $ git push origin master # Come Back up to the Project Root $ cd .. $ echo &#34;Finish blog deploy...&#34; 해당 배포 파일은 돌아다니는 레퍼런스를 참고하여 만들었다. 하지만 우린 하나의 레포지토리만 사용하므로 public 폴더로 이동 후 한 번만 push하도록 수정했다. 마지막으로 배포 파일을 실행 하려면 아래와 같은 코드로 실행 하면 된다. $ ./deploy.sh &#34;{commit msg}&#34; # 메세지가 없어도 된다. Reference https://minyeamer.github.io/blog/hugo-blog-1/ </div><div class="post-footer">
        <a href="/posts/blog-construct/hugo_blog_2/">Read More</a><div class="post-tags">
                <i class="fas fa-tags fa-fw" aria-hidden="true"></i>&nbsp;<a href="/tags/hugo/">hugo</a>,&nbsp;<a href="/tags/blog/">blog</a></div></div>
</article><ul class="pagination"><li class="page-item ">
                    <span class="page-link">
                        <a href="/">1</a>
                    </span>
                </li><li class="page-item ">
                    <span class="page-link" aria-hidden="true">&hellip;</span>
                </li><li class="page-item ">
                    <span class="page-link">
                        <a href="/page/3/">3</a>
                    </span>
                </li><li class="page-item ">
                    <span class="page-link">
                        <a href="/page/4/">4</a>
                    </span>
                </li><li class="page-item active">
                    <span class="page-link">
                        <a href="/page/5/">5</a>
                    </span>
                </li><li class="page-item ">
                    <span class="page-link">
                        <a href="/page/6/">6</a>
                    </span>
                </li></ul></div></div>
            </main><footer class="footer">
  
</footer>
</div>
</body>

</html>

<script>
  document.addEventListener("DOMContentLoaded", function() {
      renderMathInElement(document.body, {
          delimiters: [
              {left: "$$", right: "$$", display: true},
              {left: "$", right: "$", display: false}
          ]
      });
  });
</script></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="Back to Top">
                <i class="fas fa-arrow-up fa-fw" aria-hidden="true"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
                <i class="fas fa-comment fa-fw" aria-hidden="true"></i>
            </a>
        </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/css/lightgallery-bundle.min.css"><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/thumbnail/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery@2.5.0/plugins/zoom/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/typeit@8.6.0/dist/index.umd.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":500},"data":{"id-1":"Happy Happy Coding"},"lightgallery":true,"typeit":{"cursorChar":"|","cursorSpeed":500,"data":{"id-1":["id-1"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'UA-86432198-1', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=UA-86432198-1" async></script></body>
</html>
